// Code generated by tfgen. DO NOT EDIT.

package generated

import (
	"github.com/hashicorp/terraform-plugin-framework-timeouts/resource/timeouts"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// SourceMongodbModel is the Terraform model for the mongodb source.
type SourceMongodbModel struct {
	ID                                      types.String   `tfsdk:"id"`
	Name                                    types.String   `tfsdk:"name"`
	Connector                               types.String   `tfsdk:"connector"`
	MongodbConnectionString                 types.String   `tfsdk:"mongodb_connection_string"`
	TransformsUnwrapArrayEncoding           types.String   `tfsdk:"transforms_unwrap_array_encoding"`
	TransformsUnwrapDocumentEncoding        types.String   `tfsdk:"transforms_unwrap_document_encoding"`
	DatabaseIncludeList                     types.String   `tfsdk:"database_include_list"`
	CollectionIncludeList                   types.String   `tfsdk:"collection_include_list"`
	SignalDataCollectionSchemaOrDatabase    types.String   `tfsdk:"signal_data_collection_schema_or_database"`
	TransformsInsertStaticKey1StaticField   types.String   `tfsdk:"transforms_insert_static_key1_static_field"`
	TransformsInsertStaticKey1StaticValue   types.String   `tfsdk:"transforms_insert_static_key1_static_value"`
	TransformsInsertStaticValue1StaticField types.String   `tfsdk:"transforms_insert_static_value1_static_field"`
	TransformsInsertStaticValue1StaticValue types.String   `tfsdk:"transforms_insert_static_value1_static_value"`
	TransformsInsertStaticKey2StaticField   types.String   `tfsdk:"transforms_insert_static_key2_static_field"`
	TransformsInsertStaticKey2StaticValue   types.String   `tfsdk:"transforms_insert_static_key2_static_value"`
	TransformsInsertStaticValue2StaticField types.String   `tfsdk:"transforms_insert_static_value2_static_field"`
	TransformsInsertStaticValue2StaticValue types.String   `tfsdk:"transforms_insert_static_value2_static_value"`
	PredicatesIsTopicToEnrichPattern        types.String   `tfsdk:"predicates_is_topic_to_enrich_pattern"`
	SSHEnabled                              types.Bool     `tfsdk:"ssh_enabled"`
	SSHHost                                 types.String   `tfsdk:"ssh_host"`
	SSHPort                                 types.Int64    `tfsdk:"ssh_port"`
	SSHUser                                 types.String   `tfsdk:"ssh_user"`
	SSHPublicKey                            types.String   `tfsdk:"ssh_public_key"`
	Timeouts                                timeouts.Value `tfsdk:"timeouts"`
}

// SourceMongodbSchema returns the Terraform schema for the mongodb source.
func SourceMongodbSchema() schema.Schema {
	return schema.Schema{
		Description: "Manages a MongoDB Atlas source connector.",
		MarkdownDescription: "Manages a **MongoDB Atlas source connector**.\n\n" +
			"This resource creates and manages a MongoDB Atlas source for Streamkap data pipelines.\n\n" +
			"[Documentation](https://docs.streamkap.com/streamkap-provider-for-terraform)",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed:            true,
				Description:         "Unique identifier for the source",
				MarkdownDescription: "Unique identifier for the source",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"name": schema.StringAttribute{
				Required:            true,
				Description:         "Name of the source",
				MarkdownDescription: "Name of the source",
			},
			"connector": schema.StringAttribute{
				Computed:            true,
				Description:         "Connector type",
				MarkdownDescription: "Connector type",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"mongodb_connection_string": schema.StringAttribute{
				Required:            true,
				Sensitive:           true,
				Description:         "Mongodb Connection String. See Mongodb documentation for further details. This value is sensitive and will not appear in logs or CLI output.",
				MarkdownDescription: "Mongodb Connection String. See Mongodb documentation for further details.\n\n**Security:** This value is marked sensitive and will not appear in CLI output or logs.",
			},
			"transforms_unwrap_array_encoding": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "How to encode arrays. 'Array' encodes them as Array objects but requires all values in the array to be of the same type. 'Array_String' encodes them as JSON Strings and should be used if arrays have mixed types Defaults to \"array_string\". Valid values: array, array_string.",
				MarkdownDescription: "How to encode arrays. 'Array' encodes them as Array objects but requires all values in the array to be of the same type. 'Array_String' encodes them as JSON Strings and should be used if arrays have mixed types Defaults to `array_string`. Valid values: `array`, `array_string`.",
				Default:             stringdefault.StaticString("array_string"),
				Validators: []validator.String{
					stringvalidator.OneOf("array", "array_string"),
				},
			},
			"transforms_unwrap_document_encoding": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "How to encode nested documents. 'Document' encodes them as JSON Objects, 'String' encodes them as JSON Strings Defaults to \"document\". Valid values: document, string.",
				MarkdownDescription: "How to encode nested documents. 'Document' encodes them as JSON Objects, 'String' encodes them as JSON Strings Defaults to `document`. Valid values: `document`, `string`.",
				Default:             stringdefault.StaticString("document"),
				Validators: []validator.String{
					stringvalidator.OneOf("document", "string"),
				},
			},
			"database_include_list": schema.StringAttribute{
				Required:            true,
				Description:         "Source databases to sync.",
				MarkdownDescription: "Source databases to sync.",
			},
			"collection_include_list": schema.StringAttribute{
				Required:            true,
				Description:         "Source collections to sync.",
				MarkdownDescription: "Source collections to sync.",
			},
			"signal_data_collection_schema_or_database": schema.StringAttribute{
				Required:            true,
				Description:         "Streamkap will use a collection in this database to monitor incremental snapshotting. Follow the instructions in the documentation for creating this collection and specify which database to use here.",
				MarkdownDescription: "Streamkap will use a collection in this database to monitor incremental snapshotting. Follow the instructions in the documentation for creating this collection and specify which database to use here.",
			},
			"transforms_insert_static_key1_static_field": schema.StringAttribute{
				Optional:            true,
				Description:         "The name of the static field to be added to the message key.",
				MarkdownDescription: "The name of the static field to be added to the message key.",
			},
			"transforms_insert_static_key1_static_value": schema.StringAttribute{
				Optional:            true,
				Description:         "The value of the static field to be added to the message key.",
				MarkdownDescription: "The value of the static field to be added to the message key.",
			},
			"transforms_insert_static_value1_static_field": schema.StringAttribute{
				Optional:            true,
				Description:         "The name of the static field to be added to the message value.",
				MarkdownDescription: "The name of the static field to be added to the message value.",
			},
			"transforms_insert_static_value1_static_value": schema.StringAttribute{
				Optional:            true,
				Description:         "The value of the static field to be added to the message value.",
				MarkdownDescription: "The value of the static field to be added to the message value.",
			},
			"transforms_insert_static_key2_static_field": schema.StringAttribute{
				Optional:            true,
				Description:         "The name of the static field to be added to the message key.",
				MarkdownDescription: "The name of the static field to be added to the message key.",
			},
			"transforms_insert_static_key2_static_value": schema.StringAttribute{
				Optional:            true,
				Description:         "The value of the static field to be added to the message key.",
				MarkdownDescription: "The value of the static field to be added to the message key.",
			},
			"transforms_insert_static_value2_static_field": schema.StringAttribute{
				Optional:            true,
				Description:         "The name of the static field to be added to the message value.",
				MarkdownDescription: "The name of the static field to be added to the message value.",
			},
			"transforms_insert_static_value2_static_value": schema.StringAttribute{
				Optional:            true,
				Description:         "The value of the static field to be added to the message value.",
				MarkdownDescription: "The value of the static field to be added to the message value.",
			},
			"predicates_is_topic_to_enrich_pattern": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Regex pattern to match topics for enrichment. Defaults to \"$^\".",
				MarkdownDescription: "Regex pattern to match topics for enrichment. Defaults to `$^`.",
				Default:             stringdefault.StaticString("$^"),
			},
			"ssh_enabled": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Streamkap will connect to SSH server in your network which has access to your database. This is necessary if Streamkap cannot connect directly to your database. Defaults to false.",
				MarkdownDescription: "Streamkap will connect to SSH server in your network which has access to your database. This is necessary if Streamkap cannot connect directly to your database. Defaults to `false`.",
				Default:             booldefault.StaticBool(false),
			},
			"ssh_host": schema.StringAttribute{
				Optional:            true,
				Description:         "Hostname of your SSH server. Required when ssh_enabled is true.",
				MarkdownDescription: "Hostname of your SSH server. **Conditionally Required:** This field is required when `ssh_enabled` is `true`.",
			},
			"ssh_port": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				Description:         "Port of your SSH server. Defaults to 22. Required when ssh_enabled is true.",
				MarkdownDescription: "Port of your SSH server. Defaults to `22`. **Conditionally Required:** This field is required when `ssh_enabled` is `true`.",
				Default:             int64default.StaticInt64(22),
			},
			"ssh_user": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "User that allows Streamkap to connect to SSH server. Defaults to \"streamkap\". Required when ssh_enabled is true.",
				MarkdownDescription: "User that allows Streamkap to connect to SSH server. Defaults to `streamkap`. **Conditionally Required:** This field is required when `ssh_enabled` is `true`.",
				Default:             stringdefault.StaticString("streamkap"),
			},
			"ssh_public_key": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				Description:         "Public key to add to SSH server. Defaults to \"<SSH.PUBLIC.KEY>\". Required when ssh_enabled is true.",
				MarkdownDescription: "Public key to add to SSH server. Defaults to `<SSH.PUBLIC.KEY>`. **Conditionally Required:** This field is required when `ssh_enabled` is `true`.",
				Default:             stringdefault.StaticString("<SSH.PUBLIC.KEY>"),
			},
		},
	}
}

// SourceMongodbFieldMappings maps Terraform attribute names to API field names.
var SourceMongodbFieldMappings = map[string]string{
	"mongodb_connection_string":                    "mongodb.connection.string.user.defined",
	"transforms_unwrap_array_encoding":             "transforms.unwrap.array.encoding",
	"transforms_unwrap_document_encoding":          "transforms.unwrap.document.encoding",
	"database_include_list":                        "database.include.list",
	"collection_include_list":                      "collection.include.list.user.defined",
	"signal_data_collection_schema_or_database":    "signal.data.collection.schema.or.database",
	"transforms_insert_static_key1_static_field":   "transforms.InsertStaticKey1.static.field",
	"transforms_insert_static_key1_static_value":   "transforms.InsertStaticKey1.static.value",
	"transforms_insert_static_value1_static_field": "transforms.InsertStaticValue1.static.field",
	"transforms_insert_static_value1_static_value": "transforms.InsertStaticValue1.static.value",
	"transforms_insert_static_key2_static_field":   "transforms.InsertStaticKey2.static.field",
	"transforms_insert_static_key2_static_value":   "transforms.InsertStaticKey2.static.value",
	"transforms_insert_static_value2_static_field": "transforms.InsertStaticValue2.static.field",
	"transforms_insert_static_value2_static_value": "transforms.InsertStaticValue2.static.value",
	"predicates_is_topic_to_enrich_pattern":        "predicates.IsTopicToEnrich.pattern",
	"ssh_enabled":                                  "ssh.enabled",
	"ssh_host":                                     "ssh.host",
	"ssh_port":                                     "ssh.port",
	"ssh_user":                                     "ssh.user",
	"ssh_public_key":                               "ssh.public.key.user.displayed",
}
