// Code generated by tfgen. DO NOT EDIT.

package generated

import (
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// SourceKafkadirectModel is the Terraform model for the kafkadirect source.
type SourceKafkadirectModel struct {
	ID               types.String `tfsdk:"id"`
	Name             types.String `tfsdk:"name"`
	Connector        types.String `tfsdk:"connector"`
	TopicPrefix      types.String `tfsdk:"topic_prefix"`
	TopicIncludeList types.String `tfsdk:"topic_include_list"`
	Format           types.String `tfsdk:"format"`
	SchemasEnable    types.Bool   `tfsdk:"schemas_enable"`
}

// SourceKafkadirectSchema returns the Terraform schema for the kafkadirect source.
func SourceKafkadirectSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "Kafka Direct source connector",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "Unique identifier for the source",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"name": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "Name of the source",
			},
			"connector": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "Connector type",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"topic_prefix": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "Prefix for the topic",
			},
			"topic_include_list": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "Topics to sync",
			},
			"format": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The serialised format of the data written to the Kafka topic",
				Default:             stringdefault.StaticString("string"),
				Validators: []validator.String{
					stringvalidator.OneOf("json", "string"),
				},
			},
			"schemas_enable": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "If untoggled (default), Streamkap attempts to infer schema from your data - depending on the Destination. Otherwise, Streamkap assumes the Kafka message key and value contain `schema` and `payload` structures",
				Default:             booldefault.StaticBool(false),
			},
		},
	}
}

// SourceKafkadirectFieldMappings maps Terraform attribute names to API field names.
var SourceKafkadirectFieldMappings = map[string]string{
	"topic_prefix":       "topic.prefix",
	"topic_include_list": "topic.include.list.user.defined",
	"format":             "format",
	"schemas_enable":     "schemas.enable",
}
