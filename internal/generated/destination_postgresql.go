// Code generated by tfgen. DO NOT EDIT.

package generated

import (
	"github.com/hashicorp/terraform-plugin-framework-validators/int64validator"
	"github.com/hashicorp/terraform-plugin-framework-validators/stringvalidator"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/booldefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64default"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringdefault"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
)

// DestinationPostgresqlModel is the Terraform model for the postgresql destination.
type DestinationPostgresqlModel struct {
	ID                                  types.String `tfsdk:"id"`
	Name                                types.String `tfsdk:"name"`
	Connector                           types.String `tfsdk:"connector"`
	DatabaseHostname                    types.String `tfsdk:"database_hostname"`
	DatabasePort                        types.String `tfsdk:"database_port"`
	DatabaseDatabase                    types.String `tfsdk:"database_database"`
	ConnectionUsername                  types.String `tfsdk:"connection_username"`
	ConnectionPassword                  types.String `tfsdk:"connection_password"`
	SSHEnabled                          types.Bool   `tfsdk:"ssh_enabled"`
	SSHHost                             types.String `tfsdk:"ssh_host"`
	SSHPort                             types.String `tfsdk:"ssh_port"`
	SSHUser                             types.String `tfsdk:"ssh_user"`
	TableNamePrefix                     types.String `tfsdk:"table_name_prefix"`
	SchemaEvolution                     types.String `tfsdk:"schema_evolution"`
	InsertMode                          types.String `tfsdk:"insert_mode"`
	DeleteEnabled                       types.Bool   `tfsdk:"delete_enabled"`
	PrimaryKeyMode                      types.String `tfsdk:"primary_key_mode"`
	PrimaryKeyFields                    types.String `tfsdk:"primary_key_fields"`
	TasksMax                            types.Int64  `tfsdk:"tasks_max"`
	Topic2tableMap                      types.Bool   `tfsdk:"topic2table_map"`
	TransformsChangeTopicNameMatchRegex types.String `tfsdk:"transforms_change_topic_name_match_regex"`
	TransformsChangeTopicNameMapping    types.String `tfsdk:"transforms_change_topic_name_mapping"`
	SSHPublicKey                        types.String `tfsdk:"ssh_public_key"`
}

// DestinationPostgresqlSchema returns the Terraform schema for the postgresql destination.
func DestinationPostgresqlSchema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "PostgreSQL destination connector",
		Attributes: map[string]schema.Attribute{
			"id": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "Unique identifier for the destination",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"name": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "Name of the destination",
			},
			"connector": schema.StringAttribute{
				Computed:            true,
				MarkdownDescription: "Connector type",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"database_hostname": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "PostgreSQL Hostname",
			},
			"database_port": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "PostgreSQL Port. For example, 5432",
				Default:             stringdefault.StaticString("5432"),
			},
			"database_database": schema.StringAttribute{
				Optional:            true,
				MarkdownDescription: "Database name",
			},
			"connection_username": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "Username to access the database",
			},
			"connection_password": schema.StringAttribute{
				Required:            true,
				Sensitive:           true,
				MarkdownDescription: "Password to access with the database",
			},
			"ssh_enabled": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "Streamkap will connect to SSH server in your network which has access to your database. This is necessary if Streamkap cannot connect directly to your database.",
				Default:             booldefault.StaticBool(false),
			},
			"ssh_host": schema.StringAttribute{
				Optional:            true,
				MarkdownDescription: "Hostname of your SSH server",
			},
			"ssh_port": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "Port of your SSH server",
				Default:             stringdefault.StaticString("22"),
			},
			"ssh_user": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "User that allows Streamkap to connect to SSH server",
				Default:             stringdefault.StaticString("streamkap"),
			},
			"table_name_prefix": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "Schema for the associated table name",
			},
			"schema_evolution": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "Controls how schema evolution is handled by the sink connector. For pipelines with pre-created destination tables, set to `NONE`",
				Default:             stringdefault.StaticString("basic"),
				Validators: []validator.String{
					stringvalidator.OneOf("basic", "none"),
				},
			},
			"insert_mode": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "Specifies the strategy used to insert events into the database",
				Default:             stringdefault.StaticString("insert"),
				Validators: []validator.String{
					stringvalidator.OneOf("insert", "upsert"),
				},
			},
			"delete_enabled": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "Specifies whether the connector processes DELETE or tombstone events and removes the corresponding row from the database",
				Default:             booldefault.StaticBool(false),
			},
			"primary_key_mode": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "Specifies how the connector resolves the primary key columns from the event",
				Default:             stringdefault.StaticString("record_key"),
				Validators: []validator.String{
					stringvalidator.OneOf("none", "record_key", "record_value"),
				},
			},
			"primary_key_fields": schema.StringAttribute{
				Optional:            true,
				MarkdownDescription: "Optional. Either the name of the primary key column or a comma-separated list of fields to derive the primary key from.",
			},
			"tasks_max": schema.Int64Attribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "The maximum number of active tasks",
				Default:             int64default.StaticInt64(5),
				Validators: []validator.Int64{
					int64validator.Between(1, 10),
				},
			},
			"topic2table_map": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "Falls back to Streamkap's default for tables where no match is found",
				Default:             booldefault.StaticBool(false),
			},
			"transforms_change_topic_name_match_regex": schema.StringAttribute{
				Optional:            true,
				MarkdownDescription: "Regular expression for matching topic name parts to use as the destination table (database) or file (file storage) name",
			},
			"transforms_change_topic_name_mapping": schema.StringAttribute{
				Optional:            true,
				MarkdownDescription: "Map source tables to specific destination tables. Input should be the format of `source_table_name:destination_table_name` separated by a new line",
			},
			"ssh_public_key": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "Public key to add to SSH server",
				Default:             stringdefault.StaticString("<SSH.PUBLIC.KEY>"),
			},
		},
	}
}

// DestinationPostgresqlFieldMappings maps Terraform attribute names to API field names.
var DestinationPostgresqlFieldMappings = map[string]string{
	"database_hostname":   "database.hostname.user.defined",
	"database_port":       "database.port.user.defined",
	"database_database":   "database.database.user.defined",
	"connection_username": "connection.username",
	"connection_password": "connection.password",
	"ssh_enabled":         "ssh.enabled",
	"ssh_host":            "ssh.host",
	"ssh_port":            "ssh.port",
	"ssh_user":            "ssh.user",
	"table_name_prefix":   "table.name.prefix",
	"schema_evolution":    "schema.evolution",
	"insert_mode":         "insert.mode",
	"delete_enabled":      "delete.enabled",
	"primary_key_mode":    "primary.key.mode.user.defined",
	"primary_key_fields":  "primary.key.fields",
	"tasks_max":           "tasks.max",
	"topic2table_map":     "topic2table.map.user.defined",
	"transforms_change_topic_name_match_regex": "transforms.changeTopicName.match.regex.user.defined",
	"transforms_change_topic_name_mapping":     "transforms.changeTopicName.mapping",
	"ssh_public_key":                           "ssh.public.key.user.displayed",
}
